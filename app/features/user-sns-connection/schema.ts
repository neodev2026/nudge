/**
 * User SNS Connection Table
 * 
 * Manages user SNS connection information
 * Determines which SNS channels each user receives learning card pushes through
 * 
 * Creation timing:
 * - When user connects an SNS channel
 * - Email connection auto-created on user registration
 * 
 * Relationships:
 * - auth.users (Many-to-One): Multiple SNS connections belong to one user
 * - UserProductSubscription (One-to-Many): One SNS connection can have multiple subscriptions
 * - CardSchedule (One-to-Many): One SNS connection can have multiple card pushes
 * 
 * RLS Policies:
 * - Authenticated: Users can only CRUD their own SNS connections
 * - Admin: Can view all users' SNS connections
 */
import { sql } from "drizzle-orm";
import { 
  boolean, 
  pgPolicy, 
  pgEnum, 
  pgTable, 
  text, 
  timestamp, 
  uuid, 
  index, 
  unique 
} from "drizzle-orm/pg-core";
import { authUid, authUsers, authenticatedRole } from "drizzle-orm/supabase";

import { timestamps } from "~/core/db/helpers.server";
import { isAdmin } from '~/core/db/helpers.rls';

import { SNS_TYPES } from "./constants";

/**
 * SNS Type Enum
 * Defines supported SNS channels for push notifications.
 */
export const snsType = pgEnum(
  "sns_type",
  SNS_TYPES
);

/**
 * User SNS Connection Table
 * Manages connection details for various SNS channels (Telegram, Kakao, etc.) 
 * used to deliver learning card nudges to users.
 */
export const userSNSConnection = pgTable(
  'user_sns_connection',
  {
    // Primary Key
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),
    
    // Foreign Key: References auth.users
    userId: uuid('user_id')
      .notNull()
      .references(() => authUsers.id, { 
        onDelete: 'cascade' // Delete connections if the user is deleted
      }),
    
    // SNS channel type (e.g., discord, kakao, email, telegram)
    snsType: snsType('sns_type')
      .notNull(),
    
    // SNS unique identifier (e.g., Discord ID, Phone Number, or Email)
    snsIdentifier: text('sns_identifier')
      .notNull(),

    // Connection status (Used for logical deletion or disabling)
    isActive: boolean('is_active')
      .notNull()
      .default(true),
    
    // Primary push channel indicator (One primary channel per user)
    isPrimary: boolean('is_primary')
      .notNull()
      .default(false),
    
    // Global push toggle for this specific connection
    pushEnabled: boolean('push_enabled')
      .notNull()
      .default(true),
    
    // Verification timestamp (NULL indicates the connection is not yet verified)
    verifiedAt: timestamp('verified_at', { withTimezone: true }),

    /**
     * Temporary token for bot-side verification.
     * Generated by the web app and sent back by the bot via n8n.
     */
    verificationToken: text('verification_token'),

    /**
     * Expiration time for the verification token.
     */
    tokenExpiresAt: timestamp('token_expires_at', { withTimezone: true }),    
    
    // Standard timestamps (created_at, updated_at)
    ...timestamps,
  },
  (table) => [
    // CONSTRAINTS
    // Prevent duplicate SNS types/identifiers for the same user
    unique('user_sns_connection_unique')
      .on(table.userId, table.snsType, table.snsIdentifier),
    
    // INDEXES
    // Optimized lookup for user's SNS connections
    index('user_sns_user_idx').on(table.userId),
    
    // Optimized lookup for active connections (Fixes 42703 error)
    index('user_sns_active_idx').on(table.userId, table.isActive),
    
    // Optimized lookup for primary channels
    index('user_sns_primary_idx').on(table.userId, table.isPrimary),
    
    // Optimized lookup for SNS types
    index('user_sns_type_idx').on(table.snsType),
    
    // Optimized lookup by SNS identifier (e.g., finding a user by Discord ID)
    index('user_sns_identifier_idx').on(table.snsIdentifier),
    
    // Optimized lookup for verified connections
    index('user_sns_verified_idx').on(table.userId, table.verifiedAt),

    /**
     * Index for n8n to quickly find a connection by its verification token.
     */
    index('user_sns_token_idx').on(table.verificationToken),    
    
    // RLS POLICIES

    // Policy: Authenticated users can select their own SNS connections
    pgPolicy('user_sns_select_own', {
      for: 'select',
      to: authenticatedRole,
      using: sql`${table.userId} = ${authUid}`,
    }),
    
    // Policy: Admin can select all SNS connections
    pgPolicy('user_sns_select_admin', {
      for: 'select',
      to: authenticatedRole,
      using: isAdmin,
    }),

    // Policy: n8n_worker can select connections to identify push targets
    pgPolicy('user_sns_worker_select', {
      for: 'select',
      to: 'n8n_worker',
      using: sql`true`,
    }),
    
    // Policy: n8n_worker can update connections to identify push targets
    pgPolicy('user_sns_worker_update_restricted', {
      for: 'update',
      to: 'n8n_worker',
      // Only allow updating rows that are currently in "pending" status (verification_token exists)
      using: sql`verification_token IS NOT NULL`,
      withCheck: sql`true`,
    }),
        
    // Policy: Authenticated users can insert their own connections
    pgPolicy('user_sns_insert_own', {
      for: 'insert',
      to: authenticatedRole,
      withCheck: sql`${table.userId} = ${authUid}`,
    }),
    
    // Policy: Admin can insert any SNS connection
    pgPolicy('user_sns_insert_admin', {
      for: 'insert',
      to: authenticatedRole,
      withCheck: isAdmin,
    }),
    
    // Policy: Authenticated users can update their own connections
    pgPolicy('user_sns_update_own', {
      for: 'update',
      to: authenticatedRole,
      using: sql`${table.userId} = ${authUid}`,
      withCheck: sql`${table.userId} = ${authUid}`,
    }),
    
    // Policy: Admin can update any SNS connection
    pgPolicy('user_sns_update_admin', {
      for: 'update',
      to: authenticatedRole,
      using: isAdmin,
      withCheck: isAdmin,
    }),
    
    // Policy: Authenticated users can delete their own connections
    pgPolicy('user_sns_delete_own', {
      for: 'delete',
      to: authenticatedRole,
      using: sql`${table.userId} = ${authUid}`,
    }),
    
    // Policy: Admin can delete any SNS connection
    pgPolicy('user_sns_delete_admin', {
      for: 'delete',
      to: authenticatedRole,
      using: isAdmin,
    }),
  ],
);

// TypeScript Types
export type UserSNSConnection = typeof userSNSConnection.$inferSelect;
export type NewUserSNSConnection = typeof userSNSConnection.$inferInsert;